function init_ctrl (canvas, log = !1) { info = { mouse: new Array(8), mouse_v: new Array(8), scale: 1, scale_i: 0, scale_v: 0, key: new Array(256), key_v: new Array(256), pt: { x: 0, y: 0 }, pt_v: 0, touch: [], canvas: canvas }, canvas.style.backgroundColor = "#000"; for (let i in info.key) info.key[i] = !1; for (let i in info.key_v) info.key_v[i] = 0; let logout = (...args) => { }; function add_event (flag, on_call) { window.addEventListener(flag, event => { on_call && on_call(event) || (event.stopPropagation(), event.preventDefault()) }, { passive: !1 }) } return log && (logout = console.log), add_event("keydown", event => { if (event.keyCode >= 112 && event.keyCode <= 123) return !0; if ("INPUT" == document.activeElement.tagName) return !0; let i = event.keyCode; info.key[i] || (info.key[i] = !0, info.key_v++, logout("dn", i)) }), add_event("keyup", event => { let i = event.keyCode; info.key[i] && (info.key[i] = !1), logout("up", i) }), add_event("mousemove", event => (info.pt.x = event.pageX, info.pt.y = event.pageY, info.pt_v++, !0)), add_event("mousedown", event => { let i = event.button; return info.mouse[i] || (info.mouse[i] = !0, info.mouse_v++, logout("ms dn", i, document.activeElement.tagName)), !0 }), add_event("mouseup", event => { let i = event.button; return info.mouse[i] && (info.mouse[i] = !1), logout("ms up", i), !0 }), add_event("wheel", event => { if (!event.ctrlKey) { if (event.target !== document.body) return !0; info.scale_i -= event.wheelDelta / 180, info.scale = Math.pow(1.3, info.scale_i), logout("wh ", info.scale) } }), add_event("touchstart", event => (event.touches ? info.touch = event.touches : info.touch = [], !0)), add_event("touchmove", event => { event.touches ? info.touch = event.touches : info.touch = [] }), add_event("touchend", event => (event.touches ? info.touch = event.touches : info.touch = [], !0)), add_event("gesturestart", event => { logout("1") }), add_event("gesturechange", event => { logout("2") }), add_event("gestureend", event => { logout("3") }), add_event("selectstart", event => { logout("slect") }), add_event("click", event => { logout("kkkk") }), add_event("dblclick", event => { logout("kkkk") }), info } function fetch_file (url, timeout = 5e3) { return new Promise(resolve => { let xhr = new XMLHttpRequest; xhr.open("get", url, !0), xhr.timeout = timeout, xhr.onload = function () { 200 == this.status ? resolve(this.response) : resolve(null) }, xhr.ontimeout = function () { resolve(null) }, xhr.send() }) } function append_element (root, type = "font") { let t = document.createElement(type); return root.appendChild(t), t } function append_text (root, text, size = "10px") { let t = document.createElement("font"); return t.innerHTML = text, t.style.fontSize = size, root.appendChild(t), t } async function init_prog (gl, vsSource, fsSource, attr = [], unif = []) { async function loadShader (gl, type, file) { let src = await fetch_file(file); if (null == src) return null; let shader = gl.createShader(type); return gl.shaderSource(shader, src), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : (alert("shader compiling err: " + gl.getShaderInfoLog(shader)), gl.deleteShader(shader), null) } let vs = await loadShader(gl, gl.VERTEX_SHADER, vsSource), fs = await loadShader(gl, gl.FRAGMENT_SHADER, fsSource), prog = gl.createProgram(); if (gl.attachShader(prog, vs), gl.attachShader(prog, fs), gl.linkProgram(prog), !gl.getProgramParameter(prog, gl.LINK_STATUS)) return alert("shader prog err: " + gl.getProgramInfoLog(prog)), null; let info = { prog: prog, attr: {}, unif: {} }; for (let t in attr) info.attr[attr[t]] = gl.getAttribLocation(prog, attr[t]); for (let t in unif) info.unif[unif[t]] = gl.getUniformLocation(prog, unif[t]); return info } class OBSERVE_3D { constructor() { this.objs = {} } init (info, gl, prog_info, angle = 60) { this.gl = gl, this.info = info, this.prog_info = prog_info, this.a = angle, this.d = 2e3, this.cen = new tensor_tool.vec3(0), this.ang = new tensor_tool.vec2(0), this.mode = 0, this.last_pt = null, this.touch = {}, this.num_ctrl = -1, this.base_sc0 = 5e-4, this.base_sc1 = 0 } update () { let f = this.info; if (!f) return; let vec2 = tensor_tool.vec2, vec3 = tensor_tool.vec3, cvec3 = tensor_tool.cvec3, quat = tensor_tool.quat; function move_cam (self, mode, dx, dy) { if (mode) { let a_xz = vec2.gen_arc(self.ang.x), a_y = vec2.gen_arc(self.ang.y), k = new vec3(a_xz.y * a_y.x, a_y.y, -a_xz.x * a_y.x).vec(), j = new vec3(-a_xz.y * a_y.y, a_y.x, a_xz.x * a_y.y).vec(), i = j.crs(k), h = 2 * Math.tan(.5 * self.a * Math.PI / 180) * self.d / f.canvas.height; self.cen.add_(i.mul(-dx * h).add(j.mul(dy * h))) } else self.ang.add_(new vec2(dx, -dy).mul(.006)) } if (this.d = f.scale / this.base_sc0, 2 != this.mode) { if (f.mouse[1]) { if (null != this.last_pt) { let dx = f.pt.x - this.last_pt.x, dy = f.pt.y - this.last_pt.y; move_cam(this, f.key[16], dx, dy) } this.last_pt = { x: f.pt.x, y: f.pt.y } } else this.last_pt = null; if (!f.key[16]) { let vel = .01 * this.d, up = cvec3.y.mul(vel), g = quat.gen_axi(cvec3.y, -this.ang.x), front = g.rot_vec(cvec3._z).mul(vel), right = g.rot_vec(cvec3.x).mul(vel); f.key[81] && this.cen.add_(up), f.key[69] && this.cen.sub_(up), f.key[87] && this.cen.add_(front), f.key[83] && this.cen.sub_(front), f.key[68] && this.cen.add_(right), f.key[65] && this.cen.sub_(right) } f.mouse[1] || f.key[81] || f.key[69] || f.key[87] || f.key[83] || f.key[68] || f.key[65] ? this.mode = 1 : this.mode = 0 } { let changed = !1, ctrl = [], tch = {}; for (let i = 0; i < f.touch.length; i++) { let t1 = f.touch[i], p = new vec2(t1.pageX, t1.pageY), t2 = this.touch[t1.identifier]; t2 ? t2.s && ctrl.push(t2) : t2 = { p: p, s: !1 }, t2.dp = p.sub(t2.p), t2.p = p, tch[t1.identifier] = t2 } this.touch = tch; for (let i in tch) { if (ctrl.length >= 2) break; tch[i].s || (tch[i].s = !0, ctrl.push(tch[i]), changed = !0) } if (1 != this.mode) if (ctrl.length > 0) { let p = new vec2, dp = new vec2; for (let i in ctrl) p.add_(ctrl[i].p), dp.add_(ctrl[i].dp); p.div_(ctrl.length), dp.div_(ctrl.length); let dst = 0; for (let i in ctrl) dst += ctrl[i].p.sub(p).len(); dst /= ctrl.length, this.num_ctrl == ctrl.length && ctrl.length > 1 && !changed && (this.base_sc0 *= dst / this.base_sc1), this.base_sc1 = dst, move_cam(this, ctrl.length > 1, dp.x, dp.y), this.mode = 2 } else this.mode = 0; this.num_ctrl = ctrl.length } this.mat_proj = mat4.create(), mat4.perspective(this.mat_proj, this.a * Math.PI / 180, f.canvas.width / f.canvas.height, .1, 1e5), this.mat_view = mat4.create(), mat4.translate(this.mat_view, this.mat_view, [0, 0, -this.d]), mat4.rotate(this.mat_view, this.mat_view, -this.ang.y, [1, 0, 0]), mat4.rotate(this.mat_view, this.mat_view, this.ang.x, [0, 1, 0]), mat4.translate(this.mat_view, this.mat_view, [-this.cen.x, -this.cen.y, -this.cen.z]) } async open_obj (name) { if (this.objs[name]) return this.objs[name]; let gl = this.gl; if (!gl) return null; let obj = await fetch_file(name); if (!obj) return null; console.log("objload"); let ps = [], fs = [], objs = obj.split(/\s/); for (let key in objs) { let k = Number(key); "v" == objs[k] ? k + 3 < objs.length && ps.push(new tensor_tool.vec3(Number.parseInt(objs[k + 1]), Number.parseInt(objs[k + 2]), Number.parseInt(objs[k + 3]))) : "f" == objs[k] && k + 3 < objs.length && fs.push({ a: Number.parseInt(objs[k + 1].match(/\d+/)), b: Number.parseInt(objs[k + 2].match(/\d+/)), c: Number.parseInt(objs[k + 3].match(/\d+/)) }) } let pos = [], idx = [], nor = [], cnt = 0; for (let i in fs) { function push (l, p) { l.push(p.x, p.y, p.z) } let f = fs[i], pa = ps[f.a - 1], pb = ps[f.b - 1], pc = ps[f.c - 1], n = pb.sub(pa).vec().crs(pc.sub(pa).vec()).vec(); push(nor, n), push(nor, n), push(nor, n), push(pos, pa), push(pos, pb), push(pos, pc), idx.push(cnt, cnt + 1, cnt + 2), cnt += 3 } let buf_pos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf_pos), gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW); let buf_nor = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf_nor), gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nor), gl.STATIC_DRAW); let buf_idx = gl.createBuffer(); return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf_idx), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), gl.STATIC_DRAW), this.objs[name] = { gl: gl, pos: buf_pos, idx: buf_idx, nor: buf_nor, cnt: cnt } } draw_obj (obj, frm = tensor_tool.cframe.o) { let p = frm.xyz, x = frm.x(), y = frm.y(), z = frm.z(), mat = mat4.create(); mat4.set(mat, x.x, x.y, x.z, 0, y.x, y.y, y.z, 0, z.x, z.y, z.z, 0, p.x, p.y, p.z, 1); let prog_in = this.prog_info, gl = this.gl; gl.useProgram(prog_in.prog), gl.frontFace(gl.CW), gl.enable(gl.DEPTH_TEST), gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.bindBuffer(gl.ARRAY_BUFFER, obj.pos), gl.vertexAttribPointer(prog_in.attr.vertex, 3, gl.FLOAT, !1, 0, 0), gl.enableVertexAttribArray(prog_in.attr.vertex), gl.bindBuffer(gl.ARRAY_BUFFER, obj.nor), gl.vertexAttribPointer(prog_in.attr.normal, 3, gl.FLOAT, !1, 0, 0), gl.enableVertexAttribArray(prog_in.attr.normal), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.idx), gl.uniformMatrix4fv(prog_in.unif.mat_proj, !1, this.mat_proj), gl.uniformMatrix4fv(prog_in.unif.mat_view, !1, this.mat_view), gl.uniformMatrix4fv(prog_in.unif.mat_mod, !1, mat), gl.enable(gl.DEPTH_TEST), gl.drawElements(gl.TRIANGLES, obj.cnt, gl.UNSIGNED_SHORT, 0) } to_screen (pp = tensor_tool.cvec3.o) { let f = this.info; if (!f) return null; function in_screen (p) { return p.x <= 1 && p.y <= 1 && p.x >= -1 && p.y >= -1 } let vec2 = tensor_tool.vec2, vec3 = tensor_tool.vec3, a_xz = vec2.gen_arc(this.ang.x), a_y = vec2.gen_arc(this.ang.y), k = new vec3(-a_xz.y * a_y.x, -a_y.y, a_xz.x * a_y.x).vec(), j = new vec3(-a_xz.y * a_y.y, a_y.x, a_xz.x * a_y.y).vec(), i = k.crs(j), p = pp.sub(this.cen), z = -k.dot(p) + this.d; if (z < 0) return null; let x = i.dot(p), y = j.dot(p), h = f.canvas.height / (2 * Math.tan(.5 * this.a * Math.PI / 180) * z), pt; return new vec3(x * h + f.canvas.width / 2, -y * h + f.canvas.height / 2, 1 / z) } } obs = new OBSERVE_3D;