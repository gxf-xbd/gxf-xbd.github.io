let tensor_tool = {}; { let cfloat = { pi2: 2 * Math.PI, pi: Math.PI, pi_2: .5 * Math.PI, pi_4: .35 * Math.PI, to_deg: 180 / Math.PI, to_arc: Math.PI / 180 }; class vec2 { constructor(x = 0, y = null) { null == y ? this.x = this.y = x : (this.x = x, this.y = y) } rev () { return new vec2(-this.x, -this.y) } len2 () { return this.x * this.x + this.y * this.y } len () { return Math.sqrt(this.len2()) } dot (v) { return this.x * v.x + this.y * v.y } add (v) { return new vec2(this.x + v.x, this.y + v.y) } sub (v) { return new vec2(this.x - v.x, this.y - v.y) } mul (s) { return new vec2(this.x * s, this.y * s) } div (s) { return new vec2(this.x / s, this.y / s) } add_ (v) { this.x += v.x, this.y += v.y } sub_ (v) { this.x -= v.x, this.y -= v.y } mul_ (s) { this.x *= s, this.y *= s } div_ (s) { this.x /= s, this.y /= s } vec () { let s = this.len(); return s = 0 == s ? 0 : 1 / s, new vec2(this.x * s, this.y * s) } nor () { let s = this.len(); s = 0 == s ? 0 : 1 / s, this.x *= s, this.y *= s } ipo (p, r = .5) { return new vec2(this.x * (1 - r) + p.x * r, this.y * (1 - r) + p.y * r) } static gen_arc (arc, len = 1) { return new vec2(Math.cos(arc) * len, Math.sin(arc) * len) } } let cvec2 = { o: new vec2, x: new vec2(1, 0), y: new vec2(0, 1), _x: new vec2(-1, 0), _y: new vec2(0, -1), xy: new vec2(1, 1) }; class vec3 { constructor(x = 0, y = null, z = null) { null == y || null == z ? this.x = this.y = this.z = x : (this.x = x, this.y = y, this.z = z) } rev () { return new vec3(-this.x, -this.y, -this.z) } len2 () { return this.x * this.x + this.y * this.y + this.z * this.z } len () { return Math.sqrt(this.len2()) } add (v) { return new vec3(this.x + v.x, this.y + v.y, this.z + v.z) } sub (v) { return new vec3(this.x - v.x, this.y - v.y, this.z - v.z) } mul (s) { return new vec3(this.x * s, this.y * s, this.z * s) } div (s) { return new vec3(this.x / s, this.y / s, this.z / s) } add_ (v) { this.x += v.x, this.y += v.y, this.z += v.z } sub_ (v) { this.x -= v.x, this.y -= v.y, this.z -= v.z } mul_ (s) { this.x *= s, this.y *= s, this.z *= s } div_ (s) { this.x /= s, this.y /= s, this.z /= s } vec () { let s = this.len(); return s = 0 == s ? 0 : 1 / s, new vec3(this.x * s, this.y * s, this.z * s) } nor () { let s = this.len(); s = 0 == s ? 0 : 1 / s, this.x *= s, this.y *= s, this.z *= s } dot (v) { return this.x * v.x + this.y * v.y + this.z * v.z } crs (v) { return new vec3(v.y * this.z - v.z * this.y, v.z * this.x - v.x * this.z, v.x * this.y - v.y * this.x) } ipo (p, r = .5) { return new vec3(this.x * (1 - r) + p.x * r, this.y * (1 - r) + p.y * r, this.z * (1 - r) + p.z * r) } } let cvec3 = { o: new vec3, x: new vec3(1, 0, 0), y: new vec3(0, 1, 0), z: new vec3(0, 0, 1), _x: new vec3(-1, 0, 0), _y: new vec3(0, -1, 0), _z: new vec3(0, 0, -1), xyz: new vec3(1, 1, 1), black: new vec3(0), dark: new vec3(.3), gray: new vec3(.5), light: new vec3(.7), white: new vec3(1), red: new vec3(1, 0, 0), orange: new vec3(.9, .5, .1), yellow: new vec3(.9, .9, .1), chartreuse: new vec3(.5, .9, .1), green: new vec3(0, 1, 0), cyan: new vec3(.1, .9, .5), indigo: new vec3(.1, .5, .9), blue: new vec3(0, 0, 1), purple: new vec3(.5, .1, .9), rose: new vec3(.9, .1, .5) }; class quat { constructor(s = 1, i = 0, j = 0, k = 0) { this.s = s, this.i = i, this.j = j, this.k = k } identity () { this.s = 1, this.i = this.j = this.k = 0 } len2 () { return this.s * this.s + this.i * this.i + this.j * this.j + this.k * this.k } nor () { let div = this.len2(); div <= 0 || (div = 1 / Math.sqrt(div), this.s *= div, this.i *= div, this.j *= div, this.k *= div) } rotate_axi (axi, arc) { this.s = Math.sin(.5 * arc) / axi.len(), this.i = axi.x * this.s, this.j = axi.y * this.s, this.k = axi.z * this.s, this.s = Math.cos(.5 * arc) } rotate_abc (abc) { let arc = abc.len(); this.s = Math.sin(.5 * arc) / arc, this.i = abc.x * this.s, this.j = abc.y * this.s, this.k = abc.z * this.s, this.s = Math.cos(.5 * arc) } rotate_ft (from, to) { let ln2 = from.len2() * to.len2(), ln = Math.sqrt(ln2), dt = from.dot(to), cr = to.crs(from), dv = Math.sqrt(.5 / (ln2 + ln * dt)); this.s = dv * (dt + ln), this.i = dv * cr.x, this.j = dv * cr.y, this.k = dv * cr.z } static gen_axi (axi, arc) { let q = new quat; return q.rotate_axi(axi, arc), q } static gen_abc (abc) { let q = new quat; return q.rotate_abc(abc), q } static gen_xy (x, y) { x = x.vec(); let z = crs(y, x).vec(); y = crs(x, z).vec(); let m = [[x.x, x.y, x.z], [y.x, y.y, y.z], [z.x, z.y, z.z]], sqrt2 = a => a > 0 ? sqrt(a) : 0; return q = new quat(.5 * sqrt2(1 + m[0][0] + m[1][1] + m[2][2]), .5 * sqrt2(1 + m[0][0] - m[1][1] - m[2][2]), .5 * sqrt2(1 - m[0][0] + m[1][1] - m[2][2]), .5 * sqrt2(1 - m[0][0] - m[1][1] + m[2][2])), 0 != q.s ? (m[1][2] < m[2][1] ^ q.s < 0 && (q.i = -q.i), m[2][0] < m[0][2] ^ q.s < 0 && (q.j = -q.j), m[0][1] < m[1][0] ^ q.s < 0 && (q.k = -q.k)) : 0 != q.i ? (m[0][1] + m[1][0] < 0 ^ q.i < 0 && (q.j = -q.j), m[2][0] + m[0][2] < 0 ^ q.i < 0 && (q.k = -q.k)) : 0 != q.j && m[1][2] + m[2][1] < 0 ^ q.j < 0 && (q.k = -q.k), q } as_cooked (a) { let bs = this.s, bi = this.i, bj = this.j, bk = this.k; this.s = bs * a.s - bi * a.i - bj * a.j - bk * a.k, this.i = bs * a.i + bi * a.s + bj * a.k - bk * a.j, this.j = bs * a.j + bj * a.s + bk * a.i - bi * a.k, this.k = bs * a.k + bk * a.s + bi * a.j - bj * a.i } rev () { return new quat(-this.s, this.i, this.j, this.k) } cook (a) { return new quat(this.s * a.s - this.i * a.i - this.j * a.j - this.k * a.k, this.s * a.i + this.i * a.s + this.j * a.k - this.k * a.j, this.s * a.j + this.j * a.s + this.k * a.i - this.i * a.k, this.s * a.k + this.k * a.s + this.i * a.j - this.j * a.i) } rot_vec (a) { let ii = this.i * this.i, jj = this.j * this.j, kk = this.k * this.k, ij = this.i * this.j, jk = this.j * this.k, ki = this.k * this.i, is = this.i * this.s, js = this.j * this.s, ks = this.k * this.s; return new vec3(2 * ((.5 - jj - kk) * a.x + (ij - ks) * a.y + (ki + js) * a.z), 2 * ((ij + ks) * a.x + (.5 - ii - kk) * a.y + (jk - is) * a.z), 2 * ((ki - js) * a.x + (jk + is) * a.y + (.5 - ii - jj) * a.z)) } sin () { return Math.sqrt(this.i * this.i + this.j * this.j + this.k * this.k) } cos () { return Math.abs(s) } ipo (q2, r = .5) { let q1 = this; r > 1 ? r = 1 : r < 0 && (r = 0); let r2 = 1 - r, cs; q1.s * q2.s + q1.i * q2.i + q1.j * q2.j + q1.k * q2.k < 0 && (r = -r); let s = q1.s * r2 + q2.s * r, i = q1.i * r2 + q2.i * r, j = q1.j * r2 + q2.j * r, k = q1.k * r2 + q2.k * r, div = 1 / Math.sqrt(s * s + i * i + j * j + k * k); return new quat(s * div, i * div, j * div, k * div) } } let cquat = { o: new quat, x90: quat.gen_axi(cvec3.x, cfloat.pi_2), y90: quat.gen_axi(cvec3.y, cfloat.pi_2), z90: quat.gen_axi(cvec3.z, cfloat.pi_2), x180: quat.gen_axi(cvec3.x, cfloat.pi), y180: quat.gen_axi(cvec3.y, cfloat.pi), z180: quat.gen_axi(cvec3.z, cfloat.pi), x270: quat.gen_axi(cvec3.x, -cfloat.pi_2), y270: quat.gen_axi(cvec3.y, -cfloat.pi_2), z270: quat.gen_axi(cvec3.z, -cfloat.pi_2), x: deg => quat.gen_axi(cvec3.x, cfloat.to_arc * deg), y: deg => quat.gen_axi(cvec3.y, cfloat.to_arc * deg), z: deg => quat.gen_axi(cvec3.z, cfloat.to_arc * deg) }; class frame { constructor(p = cvec3.o, q = cquat.o) { this.xyz = p, this.abc = q } from_3pt (po, px, py) { this.xyz = po, this.abc = quat.gen_xy(px.sub(po), py.sub(po)) } gap (f) { return { x: this.xyz.sub(f.xyz).len(), y: quat.interval(this.abc, f.abc) } } rev () { return new frame(this.abc.rev().rot_vec(this.xyz.rev()), this.abc.rev()) } on (f) { return new frame(f.abc.rot_vec(this.xyz).add(f.xyz), f.abc.cook(this.abc)) } at (f) { return new constructor(f.abc.rev().rot_vec(xyz - f.xyz), f.abc.rev().cook(this.abc)) } on_ (f) { this.xyz = f.abc.rot_vec(xyz).add(f.xyz), this.abc = f.abc.cook(this.abc) } at_ (f) { xyz = f.abc.rev().rot_vec(xyz - f.xyz), abc = f.abc.rev().cook(this.abc) } trans (p) { return this.abc.rot_vec(p).add(this.xyz) } measure (p) { return this.abc.rev().rot_vec(p.sub(this.xyz)) } move (ds) { return new frame(this.xyz.add(ds), this.abc) } move_ (ds) { this.xyz.add_(ds) } x () { return this.abc.rot_vec(new vec3(1, 0, 0)) } y () { return this.abc.rot_vec(new vec3(0, 1, 0)) } z () { return this.abc.rot_vec(new vec3(0, 0, 1)) } ipo (f2, r = .5) { return r > 1 ? r = 1 : r < 0 && (r = 0), new constructor(this.xyz.ipo(f2.xyz, r), this.abc.ipo(f2.abc, r)) } } let cframe = { o: new frame, x90: new frame(cvec3.o, cquat.x90), y90: new frame(cvec3.o, cquat.x90), z90: new frame(cvec3.o, cquat.z90), x180: new frame(cvec3.o, cquat.x180), y180: new frame(cvec3.o, cquat.y180), z180: new frame(cvec3.o, cquat.z180), x270: new frame(cvec3.o, cquat.x270), y270: new frame(cvec3.o, cquat.y270), z270: new frame(cvec3.o, cquat.z270), x: deg => new frame(cvec3.o, cquat.x(deg)), y: deg => new frame(cvec3.o, cquat.y(deg)), z: deg => new frame(cvec3.o, cquat.z(deg)) }; function deepFreeze (obj) { return Object.getOwnPropertyNames(obj).forEach(name => { let prop = obj[name]; "object" == typeof prop && null !== prop && deepFreeze(prop) }), Object.freeze(obj) } tensor_tool.cfloat = deepFreeze(cfloat), tensor_tool.vec2 = vec2, tensor_tool.cvec2 = deepFreeze(cvec2), tensor_tool.vec3 = vec3, tensor_tool.cvec3 = deepFreeze(cvec3), tensor_tool.quat = quat, tensor_tool.cquat = deepFreeze(cquat), tensor_tool.frame = frame, tensor_tool.cframe = deepFreeze(cframe) }